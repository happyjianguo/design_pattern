 可见，2种方案都实现了同一个引用根据不同的实现执行特定的算法。是的，分析发现，在上面简单的应用中，Context的确可以取消。
 那么，Context这个角色为什么还要存在呢？ 
  让我们考虑以下几种情况： 
 1、如果我们需要对不同策略中相同算法的参数，执行相同的安全性检查，我们如果没有环境角色Context，
       则只能在每个实现的开始部分，调用安全性检查代码；而有了Context这个角色，我们可以在调用Context的构造器时，
       统一进行安全性检查。这在我们的实现策略比较多的时候，比如说7、8个的时候，特别有用，可以大量减少冗余的代码量。 

 2、如果我们需要改变原有算法时，需要引进新的参数，如果没有Context，我们怎么办？一种办法是重载该算法，
        增加新的函数接口；另外一种办法是完全废弃原有的函数接口，重新写新的函数接口。毋庸置疑，这2种办法的代价都很大，
        尤其是如果这个新的参数只有部分实现策略中的该算法实现用到的时候。而我们使用Context就可以完全解决这个问题。 
